library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

entity project_top_level is
    port (
        MAX10_CLK1_50   : in std_logic;
        reset_L : in std_logic;
        pause   : in std_logic;

        VGA_HS  : out std_logic;
        VGA_VS  : out std_logic;

        VGA_R, VGA_G, VGA_B : out std_logic_vector(3 downto 0)
    );
end entity project_top_level;

architecture rtl of project_top_level is
    component vga_controller is
	port(
		pixel_clk	:	IN		STD_LOGIC;	--pixel clock at frequency of VGA mode being used
		reset_n		:	IN		STD_LOGIC;	--active low asycnchronous reset
		h_sync		:	OUT	STD_LOGIC;	--horiztonal sync pulse
		v_sync		:	OUT	STD_LOGIC;	--vertical sync pulse
		disp_ena	:	OUT	STD_LOGIC;	--display enable ('1' = display time, '0' = blanking time)
		column		:	OUT	INTEGER;		--horizontal pixel coordinate
		row			:	OUT	INTEGER;		--vertical pixel coordinate
		n_blank		:	OUT	STD_LOGIC;	--direct blacking output to DAC
		n_sync		:	OUT	STD_LOGIC); --sync-on-green output to DAC
    end component vga_controller;

    component vga_pll_25_175 is
	port
	(
		inclk0		: IN STD_LOGIC  := '0';
		c0		: OUT STD_LOGIC 
	);
    end component vga_pll_25_175;




    

    component score is
        port (
            x      : in integer;
            y      : in integer;
            enable : in std_logic;
            score_in  : in unsigned(3 downto 0);
            red, green, blue : out std_logic_vector(3 downto 0)
        );
    end component score;

    signal vga_clk              : std_logic;
    signal global_display_en    : std_logic;
    signal global_x             : integer;
    signal global_y             : integer;

    signal x_offset : integer := '0';
    signal y_offset : integer := '0';


    signal score_x : integer;
    signal score_y : integer;
    signal score_r : std_logic_vector(3 downto 0);
    signal score_g : std_logic_vector(3 downto 0);
    signal score_b : std_logic_vector(3 downto 0);

begin

    PLL1 : vga_pll_25_175 port map (MAX10_CLK1_50, vga_clk);

    VGA_CONTROLL : vga_controller port map (
        pixel_clk => vga_clk,
        reset_n => reset_L,
        h_sync => VGA_HS,
        v_sync => VGA_VS,
        column => integer,
        row    => integer,
        n_blank => open,
        n_sync => open
    );
    
    TEST1: score port map (
        x => score_x,
        y => score_y,
        enable => global_display_en,
        score_in => open,
        red => score_r,
        green => score_g,
        blue => score_b
    );

    process (global_x, global_y, global_display_en)
    begin
        if((global_x < (x_offset + 16)) and global_y < (y_offset + 16)) THEN
            score_x <= global_x - x_offset;
            score_y <= global_y - y_offset;

            VGA_R <= score_r;
            VGA_B <= score_b;
            VGA_B <= score_b;
        else
            VGA_R <= (others => '0');
            VGA_B <= (others => '0');
            VGA_B <= (others => '0');
        end if;
    end process;

end architecture;